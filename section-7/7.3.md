# 7.3. “`typedef`”声明

“`typedef`”语句按照[5.5节](../section-5/5.5.md)的规则定义新的数据类型，可以在本模块或子模块中使用，也可以在其他模块中使用。 新类型称为“派生类型”(`derived type`)，它派生自的类型被称为“基类型”(`base type`)。 所有派生类型都可以追溯到`YANG`内置类型。

“`typedef`”语句的参数是一个标识符，它是要定义的类型的名称，必须后跟一个包含详细`typedef`信息的子语句块。

类型的名称不能与`YANG`内置类型冲突。 如果`typedef`是在`YANG`模块或子模块的顶层定义的，那么类型名称在模块中必须唯一。

## 7.3.1. `typedef`的字语句

```
+--------------+---------+-------------+
| substatement | section | cardinality |
+--------------+---------+-------------+
| default      | 7.3.4   | 0..1        |
| description  | 7.21.3  | 0..1        |
| reference    | 7.21.4  | 0..1        |
| status       | 7.21.2  | 0..1        |
| type         | 7.3.2   | 1           |
| units        | 7.3.3   | 0..1        |
+--------------+---------+-------------+
```

## 7.3.2. typedef的“`type`”语句

必选的“`type`”语句定义了此派生类型的基本类型。 细节见[第7.4节](7.4.md)。

## 7.3.3. “`units`”声明

“`units`”语句是可选的，它的参数为一个字符串，用来指定该类型数据取值关联的单位。

## 7.3.4. `typedef`的“`default`”语句

“`default`”语句使用字串来指定新类型的默认值。

“`default`”语句中的值必须是“`type`”语句中指定类型的有效值。

如果基类型具有默认值，而新派生类型不指定新的默认值，则新派生类型会继承基类型的默认值。

如果根据派生类型或叶定义中指定的新限制，基类型的缺省值无效，则派生类型或叶定义必须指定一个与有效的新缺省值。

## 7.3.5.  使用示例

```YANG
typedef listen-ipv4-address {
  type inet:ipv4-address;
  default "0.0.0.0";
}
```
