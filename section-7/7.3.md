# 7.3. “`typedef`”声明

“`typedef`”语句根据[5.5节](../section-5/5.5.md)的规则定义了一个新的类型，可以在模块或子模块中本地使用，也可以从其他模块中使用。 新类型称为“派生类型”(`derived type`)，它的派生类型被称为“基类型”(`base type`)。 所有派生类型都可以追溯到`YANG`内置类型。

“`typedef`”语句的参数是一个标识符，它是要定义的类型的名称，必须后跟一个包含详细`typedef`信息的子语句块。

类型的名称不能是`YANG`内置类型之一。 如果`typedef`是在`YANG`模块或子模块的顶层定义的，那么要定义的类型的名称在模块中必须是唯一的。

## 7.3.1. `typedef`的字语句

```
+--------------+---------+-------------+
| substatement | section | cardinality |
+--------------+---------+-------------+
| default      | 7.3.4   | 0..1        |
| description  | 7.21.3  | 0..1        |
| reference    | 7.21.4  | 0..1        |
| status       | 7.21.2  | 0..1        |
| type         | 7.3.2   | 1           |
| units        | 7.3.3   | 0..1        |
+--------------+---------+-------------+
```

## 7.3.2. typedef的“`type`”语句

必须存在的“`type`”语句定义了派生此类型的基本类型。 细节见[第7.4节](7.4.md)。

## 7.3.3. “`units`”声明

“`units`”语句是可选的，它将一个字符串作为参数，该字符串包含与该类型关联的单位的文本定义。

## 7.3.4. `typedef`的“`default`”语句

“`default`”语句将包含新类型默认值的字符串作为参数。

“`default`”语句的值必须根据“`type`”语句中指定的类型有效。

如果基类型具有默认值，而新派生类型不指定新的默认值，则基类型的默认值也是新派生类型的默认值。

如果根据派生类型或叶定义中指定的新限制，类型的缺省值无效，则派生类型或叶定义必须指定一个与限制兼容的新缺省值。

## 7.3.5.  使用示例

```YANG
typedef listen-ipv4-address {
  type inet:ipv4-address;
  default "0.0.0.0";
}
```
